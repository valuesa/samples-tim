package cn.boxfish.db.sample1.service;

/**
 * Created by LuoLiBing on 17/2/22.
 * 日志管理器
 * 解决因为服务器崩溃而导致数据没有写入到数据库文件或者部分写入破坏了原子性. 有一下两个办法:
 * 1 影子副本/页: 每个事务创建自己的数据库副本(或者数据库副本), 并基于这个副本来工作. 一旦出错, 这个副本就被移除; 一旦成功, 立即将副本文件替换成正式文件, 然后删除掉旧的数据
 * 2 事务日志: 事务日志是一个存储空间, 在每次写盘之前, 数据库在事务日志中写入一些信息, 这样当事务崩溃或回滚, 数据库知道如何移除或完成尚未完成的事务.
 *
 * WAL(预写式日志)协议
 * 1 每个对数据库的修改都产生一条日志记录, 在数据写入磁盘之前日志记录必须写入事务日志.
 * 2 日志记录必须按顺序写入, 记录A发生在记录B之前, 则A必须写在B之前
 * 3 当一个事务提交时, 在事务成功之前, 提交顺序必须写入事务日志.
 *
 * 事务日志写入的效率特别重要, 因为如果缓慢的话, 会拖慢整个数据库的写入速度.
 * ARIES 数据库恢复原型算法
 * 目标:
 * 1 写日志的同时保持良好的性能
 * 2 快速和可靠的数据恢复
 *
 * 有多个原因让数据库不得不回滚事务:
 * 1 因为用户取消
 * 2 因为服务器或网络故障
 * 3 因为事务破坏了数据库完整性
 * 4 因为死锁
 *
 * 事务日志内容
 * 1 LSN        唯一日志序列号, 按时间顺序分配.
 * 2 TranSID    产生操作的事务ID
 * 3 PageId     被修改数据磁盘的位置, 页
 * 4 PrevLSN    同一个事务产生的上一条日志记录序列号
 * 5 UNDO       取消本次操作的方法
 * 6 REDO       重复本次操作的方法
 *
 * 日志缓冲区
 * 为了防止写日志称为主要的瓶颈, 数据库使用了日志缓冲区
 *
 * 查询执行器做一次修改的流程
 * 1 缓存管理器先将修改存入自己的缓冲区
 * 2 日志管理器将相关的日志存入自己的日志缓冲区
 * 3 到这一步, 查询执行器认为操作完成了(因此可以要求做其他的修改)
 * 4 接着(短时间)日志管理器把日志写入事务日志, 什么时候写日志由某个算法来决定
 * 5 接着缓存管理器将修改写入磁盘, 什么时候写盘也由一个算法决定
 *
 * 当事务提交, 意味着事务每一个操作的12345步骤都完成了. 写事务日志很快, 因为只是在某处增加一条; 数据写盘更复杂.
 *
 * STEAL和force策略
 * 处于性能考虑, 第5步可能在事务提交之后完成, 因为一旦发生崩溃, 还可以用REDO日志恢复事务. 这叫NO-FORCE策略
 * 数据库可以选择FORCE策略(第五步在提交之前完成)来降低恢复时的负载.
 *
 * STEAL/NO-FORCE需要UNDO和REDO: 性能高, 但是日志和恢复过程更复杂. 多数数据库使用这个策略.
 *
 * STEALS崩溃恢复流程:
 * 1 分析阶段: 恢复进程读取全部日志, 来重建崩溃课程所发生事情的时间线, 决定哪些事务回滚, 崩溃时哪些数据需要写盘. (重建事务表, 脏页表)
 * 2 REDO阶段: 选取一条日志记录开始, 使用REDO将数据库恢复到崩溃之前的状态.
 *   根据日志LSN和磁盘LSN进行比较.
 *   如果LSN(磁盘)>=LSN(日志记录), 说明崩溃前, 数据已经写入磁盘, 所以不需要做什么.
 *   如果LSN(磁盘)<LSN(日志记录), 磁盘数据更新.
 * 3 UNDO: 回滚未提交的事务, 从每个事务的最后一条日志开始, 倒序处理UNDO日志.
 *
 * 事务主动回滚, 或者其他原因回滚, 分析阶段就不需要了. REDO和UNDO都在内存表:    事务表, 脏页表(需要写入磁盘的数据)
 * 为了加快分析阶段, ARIES提出了: 检查点的概念, 经常把事务表和脏页的内容写入磁盘, 还有最后一条LSN写入磁盘.
 *
 *
 *
 */
public class LogMonitor {

}
